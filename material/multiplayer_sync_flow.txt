# ============================================
# FLUXO CORRETO DE SINCRONIZAÇÃO
# ============================================

# ===== 1. CLIENTE LOCAL ENVIA ESTADO =====
# player_warrior.gd (_physics_process)

func _send_state_to_server(delta: float):
	if not is_local_player:
		return
	
	sync_timer += delta
	if sync_timer >= sync_rate:
		sync_timer = 0.0
		
		# ✅ ENVIA DIRETAMENTE PARA O SERVIDOR (peer 1)
		# usando RPC no NetworkManager (autoload global)
		NetworkManager.send_player_state(
			player_id,
			global_position,
			rotation,
			velocity,
			is_running,
			is_jumping
		)

# ===== 2. NETWORKMANAGER ENVIA PARA SERVIDOR =====
# network_manager.gd

func send_player_state(p_id: int, pos: Vector3, rot: Vector3, vel: Vector3, running: bool, jumping: bool):
	"""Cliente envia estado para o servidor"""
	if not is_connected:
		return
	
	# ✅ RPC vai para o servidor (peer 1)
	rpc_id(1, "_server_player_state", p_id, pos, rot, vel, running, jumping)

# ===== 3. SERVIDOR RECEBE E VALIDA =====
# network_manager.gd

@rpc("any_peer", "call_remote", "unreliable")
func _server_player_state(p_id: int, pos: Vector3, rot: Vector3, vel: Vector3, running: bool, jumping: bool):
	"""Servidor recebe e REDISTRIBUI para todos os clientes"""
	
	# Verifica se é servidor
	if not (multiplayer.has_multiplayer_peer() and multiplayer.get_unique_id() == 1):
		return
	
	# Valida que o remetente é quem diz ser
	var sender_id = multiplayer.get_remote_sender_id()
	if sender_id != p_id:
		push_warning("Jogador %d tentou enviar estado do jogador %d" % [sender_id, p_id])
		return
	
	# ✅ OPCIONAL: Validação anti-cheat
	if ServerManager.enable_anticheat:
		if not ServerManager._validate_player_movement(p_id, pos, vel):
			ServerManager._kick_player(p_id, "Movimento suspeito detectado")
			return
	
	# ✅ ENVIA PARA TODOS OS OUTROS CLIENTES
	for peer_id in multiplayer.get_peers():
		if peer_id != p_id:  # Não envia de volta para quem mandou
			rpc_id(peer_id, "_client_player_state", p_id, pos, rot, vel, running, jumping)

# ===== 4. CLIENTES REMOTOS RECEBEM =====
# network_manager.gd

@rpc("authority", "call_remote", "unreliable")
func _client_player_state(p_id: int, pos: Vector3, rot: Vector3, vel: Vector3, running: bool, jumping: bool):
	"""Cliente recebe estado de OUTRO jogador"""
	
	# Ignora se for o servidor
	if multiplayer.has_multiplayer_peer() and multiplayer.get_unique_id() == 1:
		return
	
	# ✅ ENCONTRA O PLAYER NA CENA
	# Os players são filhos diretos da raiz e têm como nome o player_id
	var player = get_tree().root.get_node_or_null(str(p_id))
	
	if not player:
		return
	
	# ✅ CHAMA FUNÇÃO NO PLAYER PARA ATUALIZAR
	if player.has_method("_client_receive_state"):
		player._client_receive_state(pos, rot, vel, running, jumping)

# ===== 5. PLAYER REMOTO INTERPOLA =====
# player_warrior.gd

@rpc("authority", "call_remote", "unreliable")
func _client_receive_state(pos: Vector3, rot: Vector3, vel: Vector3, running: bool, jumping: bool):
	"""Recebe estado de outros jogadores e define alvos para interpolação"""
	
	if is_local_player:
		return  # Ignora para si mesmo
	
	# ✅ ATUALIZA ALVOS PARA INTERPOLAÇÃO SUAVE
	target_position = pos
	target_rotation_y = rot.y
	velocity = vel  # Opcional: para gravidade
	
	# Atualiza estados para animações
	is_running = running
	is_jumping = jumping

# ===== 6. INTERPOLAÇÃO SUAVE NO _physics_process =====
# player_warrior.gd

func _physics_process(delta):
	if is_local_player:
		# ... processamento local normal
		_send_state_to_server(delta)
	else:
		# ✅ INTERPOLAÇÃO PARA JOGADORES REMOTOS
		_interpolate_remote_player(delta)
	
	# ... resto do código

func _interpolate_remote_player(delta: float):
	"""Interpola suavemente posição/rotação de jogadores remotos"""
	
	# Lerp suave (evita teleporte)
	global_position = global_position.lerp(target_position, interpolation_speed * delta)
	rotation.y = lerp_angle(rotation.y, target_rotation_y, interpolation_speed * delta)
	
	# Opcional: simula gravidade para remotos
	if not is_on_floor():
		velocity.y -= gravity * delta
	else:
		velocity.y = 0
	
	move_and_slide()

# ============================================
# RESUMO DO FLUXO:
# ============================================
# 1. Cliente Local → NetworkManager.send_player_state()
# 2. NetworkManager → RPC para servidor (peer 1)
# 3. Servidor valida e redistribui para outros clientes
# 4. Clientes remotos recebem via RPC
# 5. NetworkManager encontra player na cena
# 6. Player atualiza target_position/rotation
# 7. _physics_process interpola suavemente
