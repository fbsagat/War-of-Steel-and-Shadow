[gd_scene load_steps=3 format=3 uid="uid://dp2gq1l5kmxd6"]

[ext_resource type="PackedScene" uid="uid://cwu8t6cp4qo1c" path="res://sky/sky_3d.tscn" id="1_mvrc1"]

[sub_resource type="GDScript" id="GDScript_om72s"]
script/source = "@tool
extends Node3D

## Gerador de Terreno Procedural Avançado para Godot 4.x+
## Sistema completo com realismo aprimorado, múltiplas camadas de noise e materiais dinâmicos

# =============================================================================
# CONFIGURAÇÕES DO INSPETOR
# =============================================================================

@export_category(\"Configurações Básicas\")
@export var posicao_inicial := Vector3.ZERO
@export var tamanho_mapa := Vector2i(50, 50)
@export var tamanho_chunk := 16.0
@export var seed_geracao := 0

@export_category(\"Recursos\")
@export var material_terreno: Material
@export var usar_material_dinamico := true ## Sistema de materiais por altura/inclinação

@export_category(\"Player e Renderização\")
@export var distancia_render := 150.0

@export_category(\"Física\")
@export_range(1, 32) var layer_colisao: int = 1
@export_range(1, 32) var mascara_colisao: int = 1
@export var otimizar_colisao_distante: bool = true

@export_category(\"Sistema de Relevo Multi-Camadas\")
@export var etapas_relevo: Array[EtapaRelevo] = []
@export var suavizar_transicoes: bool = true
@export var tamanho_zona_transicao: float = 0.3

@export_subgroup(\"Camadas de Noise\")
@export var usar_noise_base := true ## Camada principal de terreno
@export var frequencia_base := 0.015
@export var amplitude_base := 15.0

@export var usar_noise_detalhes := true ## Adiciona detalhes finos
@export var frequencia_detalhes := 0.08
@export var amplitude_detalhes := 2.5

@export var usar_noise_montanhas := true ## Adiciona formações montanhosas
@export var frequencia_montanhas := 0.006
@export var amplitude_montanhas := 35.0
@export var threshold_montanhas := 0.4 ## Valor mínimo para gerar montanhas

@export var usar_erosao_simulada := true ## Simula erosão natural
@export var intensidade_erosao := 0.3

@export_category(\"Otimização e Performance\")
@export_enum(\"Low\", \"Medium\", \"High\", \"Ultra\") var quality_preset: String = \"Medium\"

@export_subgroup(\"LOD\")
@export var enable_lod: bool = true
@export var lod_distances: Array[float] = [50.0, 100.0, 200.0]
@export var lod_resolutions: Array[int] = [1, 2, 4, 8]

@export_subgroup(\"Culling e Pooling\")
@export var enable_frustum_culling: bool = true
@export var enable_chunk_pooling: bool = true
@export var max_chunks_per_frame: int = 2
@export var update_interval: float = 0.1

@export_category(\"Configurações Gráficas\")
@export var usar_sombras: bool = true
@export var gi_mode: GeometryInstance3D.GIMode = GeometryInstance3D.GI_MODE_STATIC
@export var cast_shadow: GeometryInstance3D.ShadowCastingSetting = GeometryInstance3D.SHADOW_CASTING_SETTING_ON
@export var criar_luz_automatica: bool = true

@export_subgroup(\"Qualidade Visual\")
@export var subdivisions: int = 32
@export var altura_maxima: float = 50.0
@export var usar_normal_mapping: bool = true

@export_category(\"Sistema de Materiais Dinâmicos\")
@export_subgroup(\"Configuração de Biomas\")
@export var material_praia: Material ## 0-2m altura
@export var material_grama: Material ## 2-15m altura
@export var material_pedra: Material ## 15-30m altura
@export var material_neve: Material ## 30m+ altura

@export_subgroup(\"Thresholds de Altura (metros)\")
@export var altura_praia_max := 2.0
@export var altura_grama_max := 15.0
@export var altura_pedra_max := 30.0

@export_subgroup(\"Inclinação\")
@export var usar_material_por_inclinacao := true
@export var angulo_pedra_min := 45.0 ## Ângulo mínimo para forçar pedra
@export var suavidade_transicao_material := 5.0 ## Suavidade da transição entre materiais

@export_category(\"Cache e Memória\")
@export var cache_meshes: bool = true
@export var max_cached_chunks: int = 500
@export var limpar_chunks_distantes: bool = true
@export var distancia_liberacao: float = 300.0

@export_category(\"Suavização Avançada\")
@export var suavizar_terreno: bool = true
@export_range(0.0, 1.0, 0.05) var intensidade_suavizacao: float = 0.4
@export_range(1, 5) var iteracoes_suavizacao: int = 2

@export_subgroup(\"Erosão Hidráulica Simplificada\")
@export var simular_erosao_hidraulica := false
@export_range(0.0, 1.0, 0.05) var fator_erosao_vales := 0.6

@export_subgroup(\"Bordas do Mapa\")
@export var arredondar_bordas_mapa: bool = true
@export_range(0.0, 1.0, 0.05) var intensidade_bordas: float = 0.8
@export_range(0.0, 100.0, 1.0) var distancia_arredondamento: float = 30.0

@export_subgroup(\"Transições entre Chunks\")
@export var suavizar_bordas_chunks: bool = true
@export_range(0.0, 10.0, 0.1) var distancia_suavizacao_borda: float = 2.0

@export_category(\"Debug\")
@export var console_debug: bool = false
@export var debug_mostrar_bordas: bool = false
@export var debug_forcar_lod_unico: bool = false
@export var debug_lod_forcado: int = 0
@export var debug_log_geracao: bool = false
@export var debug_mostrar_biomas: bool = false

# =============================================================================
# VARIÁVEIS INTERNAS
# =============================================================================

var chunks_ativos: Dictionary = {}
var chunk_pool: Array = []
var noise_base: FastNoiseLite
var noise_detalhes: FastNoiseLite
var noise_montanhas: FastNoiseLite
var noise_erosao: FastNoiseLite
var player_node: Node3D
var terrain_parent: Node3D
var mesh_cache: Dictionary = {}
var altura_cache: Dictionary = {}
var timer: float = 0.0
var camera: Camera3D
var raio_mapa_metros: float = 0.0
var total_percentual_etapas: float = 0.0

# Materiais processados
var materiais_processados: Dictionary = {}

class ChunkData:
	var mesh_instance: MeshInstance3D
	var static_body: StaticBody3D
	var collision_shape: CollisionShape3D
	var posicao_chunk: Vector2i
	var lod_atual: int = 0
	var visivel: bool = true

# =============================================================================
# INICIALIZAÇÃO
# =============================================================================

func _ready() -> void:
	if Engine.is_editor_hint():
		return
	
	terrain_parent = self
	if console_debug:
		print(\"[TerrainGen] Inicializando sistema avançado...\")
	
	_validar_configuracoes()
	_aplicar_quality_preset()
	_inicializar_seed()
	_configurar_noise_multicamadas()
	_processar_materiais()
	_obter_referencias()
	_calcular_raio_mapa()
	_configurar_etapas_relevo()
	
	if arredondar_bordas_mapa:
		_pre_processar_terreno()
	
	_gerar_chunks_iniciais()

func _validar_configuracoes() -> void:
	tamanho_chunk = max(16.0, tamanho_chunk)
	subdivisions = max(8, subdivisions)
	altura_maxima = max(10.0, altura_maxima)
	
	# Validar thresholds de materiais
	if altura_praia_max >= altura_grama_max:
		altura_praia_max = altura_grama_max - 1.0
	if altura_grama_max >= altura_pedra_max:
		altura_grama_max = altura_pedra_max - 1.0

func _inicializar_seed() -> void:
	if seed_geracao == 0:
		seed_geracao = randi()
	if console_debug:
		seed(seed_geracao)
		print(\"[TerrainGen] Seed: \", seed_geracao)

func _configurar_noise_multicamadas() -> void:
	# Noise Base - Formas principais do terreno
	noise_base = FastNoiseLite.new()
	noise_base.seed = seed_geracao
	noise_base.noise_type = FastNoiseLite.TYPE_SIMPLEX_SMOOTH
	noise_base.frequency = frequencia_base
	noise_base.fractal_type = FastNoiseLite.FRACTAL_FBM
	noise_base.fractal_octaves = 5
	noise_base.fractal_lacunarity = 2.0
	noise_base.fractal_gain = 0.5
	
	# Noise Detalhes - Variações finas
	noise_detalhes = FastNoiseLite.new()
	noise_detalhes.seed = seed_geracao + 1000
	noise_detalhes.noise_type = FastNoiseLite.TYPE_PERLIN
	noise_detalhes.frequency = frequencia_detalhes
	noise_detalhes.fractal_octaves = 3
	
	# Noise Montanhas - Formações elevadas
	noise_montanhas = FastNoiseLite.new()
	noise_montanhas.seed = seed_geracao + 2000
	noise_montanhas.noise_type = FastNoiseLite.TYPE_CELLULAR
	noise_montanhas.frequency = frequencia_montanhas
	noise_montanhas.cellular_distance_function = FastNoiseLite.DISTANCE_EUCLIDEAN
	noise_montanhas.cellular_return_type = FastNoiseLite.RETURN_CELL_VALUE
	
	# Noise Erosão - Padrões de erosão
	noise_erosao = FastNoiseLite.new()
	noise_erosao.seed = seed_geracao + 3000
	noise_erosao.noise_type = FastNoiseLite.TYPE_SIMPLEX
	noise_erosao.frequency = 0.04

func _processar_materiais() -> void:
	if not usar_material_dinamico:
		return
	
	if console_debug:
		print(\"[TerrainGen] Processando sistema de materiais dinâmicos...\")
	
	# Criar materiais padrão se não especificados
	if not material_praia:
		material_praia = _criar_material_praia()
	if not material_grama:
		material_grama = _criar_material_grama()
	if not material_pedra:
		material_pedra = _criar_material_pedra()
	if not material_neve:
		material_neve = _criar_material_neve()
	
	materiais_processados[\"praia\"] = material_praia
	materiais_processados[\"grama\"] = material_grama
	materiais_processados[\"pedra\"] = material_pedra
	materiais_processados[\"neve\"] = material_neve

func _criar_material_praia() -> StandardMaterial3D:
	var mat = StandardMaterial3D.new()
	mat.albedo_color = Color(0.85, 0.75, 0.55) # Areia bege
	mat.roughness = 0.9
	mat.metallic = 0.0
	return mat

func _criar_material_grama() -> StandardMaterial3D:
	var mat = StandardMaterial3D.new()
	mat.albedo_color = Color(0.3, 0.6, 0.25) # Verde grama
	mat.roughness = 0.85
	mat.metallic = 0.0
	return mat

func _criar_material_pedra() -> StandardMaterial3D:
	var mat = StandardMaterial3D.new()
	mat.albedo_color = Color(0.45, 0.45, 0.5) # Cinza pedra
	mat.roughness = 0.8
	mat.metallic = 0.1
	return mat

func _criar_material_neve() -> StandardMaterial3D:
	var mat = StandardMaterial3D.new()
	mat.albedo_color = Color(0.95, 0.95, 1.0) # Branco neve
	mat.roughness = 0.7
	mat.metallic = 0.0
	return mat

func _obter_referencias() -> void:
	if player_node and player_node.has_node(\"Camera3D\"):
		camera = player_node.get_node(\"Camera3D\")
	else:
		camera = get_viewport().get_camera_3d()
	
	if criar_luz_automatica:
		_verificar_e_criar_luz()

func _verificar_e_criar_luz() -> void:
	var luz_encontrada: bool = false
	var root: Window = get_tree().root
	
	for child in root.get_children():
		if _tem_luz_direcional(child):
			luz_encontrada = true
			break
	
	if not luz_encontrada:
		if console_debug:
			print(\"[TerrainGen] Criando luz automática\")
		var luz: DirectionalLight3D = DirectionalLight3D.new()
		luz.name = \"TerrainAutoLight\"
		luz.light_energy = 1.2
		luz.light_color = Color(1.0, 0.98, 0.9)
		luz.shadow_enabled = usar_sombras
		luz.rotation_degrees = Vector3(-50, 30, 0)
		root.add_child(luz)

func _tem_luz_direcional(node: Node) -> bool:
	if node is DirectionalLight3D:
		return true
	for child in node.get_children():
		if _tem_luz_direcional(child):
			return true
	return false

func _calcular_raio_mapa() -> void:
	if tamanho_mapa != Vector2i.ZERO:
		raio_mapa_metros = max(tamanho_mapa.x, tamanho_mapa.y) * tamanho_chunk * 0.5
		if console_debug:
			print(\"[TerrainGen] Raio do mapa: \", raio_mapa_metros, \"m\")

func _configurar_etapas_relevo() -> void:
	total_percentual_etapas = 0.0
	for etapa in etapas_relevo:
		total_percentual_etapas += etapa.percentual_distancia
	
	if etapas_relevo.is_empty():
		var etapa_padrao = EtapaRelevo.new()
		etapa_padrao.nome = \"Padrão\"
		etapa_padrao.tipo_relevo = \"Rolling Hills\"
		etapa_padrao.percentual_distancia = 100.0
		etapas_relevo.append(etapa_padrao)
		total_percentual_etapas = 100.0
	
	if total_percentual_etapas > 0 and abs(total_percentual_etapas - 100.0) > 0.1:
		var fator = 100.0 / total_percentual_etapas
		for etapa in etapas_relevo:
			etapa.percentual_distancia *= fator
		total_percentual_etapas = 100.0

func _aplicar_quality_preset() -> void:
	match quality_preset:
		\"Low\":
			subdivisions = 16
			lod_resolutions = [1, 2, 4, 8]
			max_chunks_per_frame = 1
		\"Medium\":
			subdivisions = 32
			lod_resolutions = [1, 2, 4, 6]
			max_chunks_per_frame = 2
		\"High\":
			subdivisions = 48
			lod_resolutions = [1, 2, 3, 4]
			max_chunks_per_frame = 3
		\"Ultra\":
			subdivisions = 64
			lod_resolutions = [1, 2, 3]
			max_chunks_per_frame = 4

# =============================================================================
# GERAÇÃO DE CHUNKS COM REALISMO APRIMORADO
# =============================================================================

func _gerar_chunks_iniciais() -> void:
	if console_debug:
		print(\"[TerrainGen] Gerando chunks iniciais...\")
	
	var centro: Vector2i = Vector2i.ZERO
	if distancia_render > 0 and player_node:
		var pos: Vector3 = player_node.global_position
		centro = Vector2i(
			int(floor(pos.x / tamanho_chunk)),
			int(floor(pos.z / tamanho_chunk))
		)
	
	var raio_chunks: int = _calcular_raio_chunks()
	var chunks_criados: int = 0
	var tempo_inicio: int = Time.get_ticks_msec()
	
	for raio in range(raio_chunks + 1):
		for x in range(-raio, raio + 1):
			for z in range(-raio, raio + 1):
				if abs(x) == raio or abs(z) == raio:
					var chunk_pos: Vector2i = Vector2i(centro.x + x, centro.y + z)
					if _chunk_dentro_limites(chunk_pos):
						_criar_chunk(chunk_pos)
						chunks_criados += 1
						
						if chunks_criados % 10 == 0:
							await get_tree().process_frame
	
	var tempo_total: int = Time.get_ticks_msec() - tempo_inicio
	if console_debug:
		print(\"[TerrainGen] Concluído! \", chunks_criados, \" chunks em \", tempo_total, \"ms\")

func _calcular_raio_chunks() -> int:
	var raio: int = 5
	
	if distancia_render > 0:
		raio = int(distancia_render / tamanho_chunk) + 1
	elif tamanho_mapa != Vector2i.ZERO:
		raio = int(max(tamanho_mapa.x, tamanho_mapa.y) / 2)
	
	return min(raio, 20)

func _criar_chunk(chunk_pos: Vector2i) -> ChunkData:
	if chunks_ativos.has(chunk_pos):
		return chunks_ativos[chunk_pos]
	
	var chunk_data: ChunkData
	
	if enable_chunk_pooling and chunk_pool.size() > 0:
		chunk_data = chunk_pool.pop_back()
		chunk_data.posicao_chunk = chunk_pos
	else:
		chunk_data = ChunkData.new()
		chunk_data.posicao_chunk = chunk_pos
		_criar_chunk_nodes(chunk_data)
	
	var lod_inicial: int = 1 if enable_lod and lod_resolutions.size() > 1 else 0
	_gerar_mesh_chunk(chunk_data, lod_inicial)
	
	var world_pos: Vector3 = Vector3(
		chunk_pos.x * tamanho_chunk + posicao_inicial.x,
		posicao_inicial.y,
		chunk_pos.y * tamanho_chunk + posicao_inicial.z
	)
	chunk_data.static_body.global_position = world_pos
	
	chunks_ativos[chunk_pos] = chunk_data
	return chunk_data

func _criar_chunk_nodes(chunk_data: ChunkData) -> void:
	chunk_data.static_body = StaticBody3D.new()
	chunk_data.static_body.collision_layer = 1 << (layer_colisao - 1)
	chunk_data.static_body.collision_mask = 1 << (mascara_colisao - 1)
	terrain_parent.add_child(chunk_data.static_body)
	
	chunk_data.mesh_instance = MeshInstance3D.new()
	chunk_data.mesh_instance.cast_shadow = cast_shadow if usar_sombras else GeometryInstance3D.SHADOW_CASTING_SETTING_OFF
	chunk_data.mesh_instance.gi_mode = gi_mode
	chunk_data.static_body.add_child(chunk_data.mesh_instance)
	
	chunk_data.collision_shape = CollisionShape3D.new()
	chunk_data.static_body.add_child(chunk_data.collision_shape)

func _gerar_mesh_chunk(chunk_data: ChunkData, lod_level: int = 0) -> void:
	var cache_key: String = str(chunk_data.posicao_chunk) + \"_\" + str(lod_level)
	
	if cache_meshes and mesh_cache.has(cache_key):
		chunk_data.mesh_instance.mesh = mesh_cache[cache_key]
		_aplicar_material_chunk(chunk_data)
		_atualizar_collision_shape(chunk_data, lod_level)
		return
	
	var lod_divisor: int = lod_resolutions[lod_level] if enable_lod and lod_level < lod_resolutions.size() else 1
	var resolution: int = clamp(subdivisions / lod_divisor, 8, 128)
	var step: float = tamanho_chunk / float(resolution)
	
	var vertices: PackedVector3Array = PackedVector3Array()
	var normals: PackedVector3Array = PackedVector3Array()
	var uvs: PackedVector2Array = PackedVector2Array()
	var colors: PackedColorArray = PackedColorArray() # Para debug de biomas
	var indices: PackedInt32Array = PackedInt32Array()
	
	var total_vertices: int = (resolution + 1) * (resolution + 1)
	vertices.resize(total_vertices)
	uvs.resize(total_vertices)
	colors.resize(total_vertices)
	indices.resize(resolution * resolution * 6)
	
	# Gerar vértices com sistema de costura
	var vertex_index: int = 0
	
	for z in range(resolution + 1):
		for x in range(resolution + 1):
			var local_x: float = x * step
			var local_z: float = z * step
			
			var global_vertex_x: float = (chunk_data.posicao_chunk.x * resolution + x) * step
			var global_vertex_z: float = (chunk_data.posicao_chunk.y * resolution + z) * step
			
			var altura: float = _obter_altura_avancada(global_vertex_x, global_vertex_z)
			
			vertices[vertex_index] = Vector3(local_x, altura, local_z)
			uvs[vertex_index] = Vector2(float(x) / float(resolution), float(z) / float(resolution))
			
			# Cor de debug por bioma
			if debug_mostrar_biomas:
				colors[vertex_index] = _obter_cor_bioma_debug(altura)
			else:
				colors[vertex_index] = Color.WHITE
			
			vertex_index += 1
	
	# Aplicar suavizações
	if suavizar_terreno:
		_aplicar_suavizacao_avancada(vertices, resolution)
	
	if arredondar_bordas_mapa and tamanho_mapa != Vector2i.ZERO:
		_aplicar_arredondamento_bordas(vertices, resolution, chunk_data.posicao_chunk)
	
	if suavizar_bordas_chunks:
		_aplicar_suavizacao_bordas_chunks(vertices, resolution)
	
	if simular_erosao_hidraulica:
		_aplicar_erosao_hidraulica(vertices, resolution)
	
	# Gerar índices
	var index_pos: int = 0
	for z in range(resolution):
		for x in range(resolution):
			var i: int = z * (resolution + 1) + x
			
			indices[index_pos] = i
			indices[index_pos + 1] = i + 1
			indices[index_pos + 2] = i + resolution + 1
			
			indices[index_pos + 3] = i + 1
			indices[index_pos + 4] = i + resolution + 2
			indices[index_pos + 5] = i + resolution + 1
			
			index_pos += 6
	
	# Calcular normais
	if usar_normal_mapping:
		normals = _calcular_normais_suaves(vertices, indices)
	else:
		normals.resize(vertices.size())
		normals.fill(Vector3.UP)
	
	# Criar mesh
	var surface_array: Array = []
	surface_array.resize(Mesh.ARRAY_MAX)
	surface_array[Mesh.ARRAY_VERTEX] = vertices
	surface_array[Mesh.ARRAY_NORMAL] = normals
	surface_array[Mesh.ARRAY_TEX_UV] = uvs
	surface_array[Mesh.ARRAY_COLOR] = colors
	surface_array[Mesh.ARRAY_INDEX] = indices
	
	var array_mesh: ArrayMesh = ArrayMesh.new()
	array_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)
	
	if cache_meshes:
		mesh_cache[cache_key] = array_mesh
		_limpar_cache_se_necessario()
	
	chunk_data.mesh_instance.mesh = array_mesh
	chunk_data.lod_atual = lod_level
	
	if debug_mostrar_bordas:
		_debug_desenhar_bordas(chunk_data)
	
	_aplicar_material_chunk(chunk_data)
	_atualizar_collision_shape(chunk_data, lod_level)

# =============================================================================
# SISTEMA DE ALTURA MULTICAMADAS
# =============================================================================

func _obter_altura_avancada(world_x: float, world_z: float) -> float:
	var cache_key: Vector3 = Vector3(
		round(world_x * 1000.0) / 1000.0,
		0,
		round(world_z * 1000.0) / 1000.0
	)
	
	if altura_cache.has(cache_key):
		return altura_cache[cache_key]
	
	var altura_final: float = 0.0
	
	# Camada Base
	if usar_noise_base:
		var valor_base: float = noise_base.get_noise_2d(world_x, world_z)
		altura_final += valor_base * amplitude_base
	
	# Camada de Detalhes
	if usar_noise_detalhes:
		var valor_detalhes: float = noise_detalhes.get_noise_2d(world_x, world_z)
		altura_final += valor_detalhes * amplitude_detalhes
	
	# Camada de Montanhas (só aplica onde o threshold é atingido)
	if usar_noise_montanhas:
		var valor_montanhas: float = noise_montanhas.get_noise_2d(world_x, world_z)
		if valor_montanhas > threshold_montanhas:
			var intensidade: float = (valor_montanhas - threshold_montanhas) / (1.0 - threshold_montanhas)
			altura_final += pow(intensidade, 1.5) * amplitude_montanhas
	
	# Erosão Simulada
	if usar_erosao_simulada:
		var erosao: float = noise_erosao.get_noise_2d(world_x, world_z)
		altura_final *= (1.0 + erosao * intensidade_erosao)
	
	# Aplicar etapas de relevo
	var distancia_centro: float = Vector2(world_x, world_z).length()
	var params: Dictionary = _obter_parametros_relevo_por_distancia(distancia_centro)
	altura_final *= params.get(\"multiplicador\", 1.0)
	
	altura_final = clamp(altura_final, 0, altura_maxima)
	
	# Suavização nas bordas dos chunks
	if suavizar_bordas_chunks:
		altura_final = _aplicar_suavizacao_ponto(world_x, world_z, altura_final)
	
	altura_cache[cache_key] = altura_final
	
	if altura_cache.size() > 20000:
		_limpar_altura_cache()
	
	return altura_final

func _aplicar_suavizacao_ponto(world_x: float, world_z: float, altura: float) -> float:
	var chunk_x: int = int(floor(world_x / tamanho_chunk))
	var chunk_z: int = int(floor(world_z / tamanho_chunk))
	
	var local_x: float = world_x - (chunk_x * tamanho_chunk)
	var local_z: float = world_z - (chunk_z * tamanho_chunk)
	
	var dist_borda_x: float = min(local_x, tamanho_chunk - local_x)
	var dist_borda_z: float = min(local_z, tamanho_chunk - local_z)
	var dist_min_borda: float = min(dist_borda_x, dist_borda_z)
	
	if dist_min_borda < distancia_suavizacao_borda:
		var fator: float = dist_min_borda / distancia_suavizacao_borda
		return altura * (0.7 + 0.3 * fator)
	
	return altura

func _obter_parametros_relevo_por_distancia(distancia_metros: float) -> Dictionary:
	if tamanho_mapa == Vector2i.ZERO:
		return {\"multiplicador\": 1.0, \"tipo\": \"Rolling Hills\"}
	
	var percentual: float = clamp(distancia_metros / raio_mapa_metros, 0.0, 1.0)
	var percentual_acumulado: float = 0.0
	
	for etapa in etapas_relevo:
		var percentual_etapa: float = etapa.percentual_distancia / 100.0
		
		if percentual <= percentual_acumulado + percentual_etapa:
			return {
				\"multiplicador\": _obter_multiplicador_tipo(etapa.tipo_relevo),
				\"tipo\": etapa.tipo_relevo
			}
		
		percentual_acumulado += percentual_etapa
	
	return {\"multiplicador\": 1.0, \"tipo\": \"Rolling Hills\"}

func _obter_multiplicador_tipo(tipo: String) -> float:
	match tipo:
		\"Flat\":
			return 0.1
		\"Semi-Flat\":
			return 0.3
		\"Gentle Hills\":
			return 0.7
		\"Rolling Hills\":
			return 1.0
		\"Valleys\":
			return 1.3
		_:
			return 1.0

# =============================================================================
# SISTEMA DE SUAVIZAÇÃO AVANÇADA
# =============================================================================

func _aplicar_suavizacao_avancada(vertices: PackedVector3Array, resolution: int) -> void:
	if not suavizar_terreno:
		return
	
	var vertices_temp: PackedVector3Array = vertices.duplicate()
	
	for iter in range(iteracoes_suavizacao):
		for z in range(1, resolution):
			for x in range(1, resolution):
				var index: int = z * (resolution + 1) + x
				
				# Média ponderada dos 8 vizinhos + centro
				var soma: float = 0.0
				var peso_total: float = 0.0
				
				# Centro (peso maior)
				soma += vertices_temp[index].y * 4.0
				peso_total += 4.0
				
				# Vizinhos cardeais (peso médio)
				var offsets_cardeais: Array = [
					Vector2i(-1, 0), Vector2i(1, 0),
					Vector2i(0, -1), Vector2i(0, 1)
				]
				
				for offset in offsets_cardeais:
					var nx: int = x + offset.x
					var nz: int = z + offset.y
					if nx >= 0 and nx <= resolution and nz >= 0 and nz <= resolution:
						var nidx: int = nz * (resolution + 1) + nx
						soma += vertices_temp[nidx].y * 2.0
						peso_total += 2.0
				
				# Vizinhos diagonais (peso menor)
				var offsets_diagonais: Array = [
					Vector2i(-1, -1), Vector2i(1, -1),
					Vector2i(-1, 1), Vector2i(1, 1)
				]
				
				for offset in offsets_diagonais:
					var nx: int = x + offset.x
					var nz: int = z + offset.y
					if nx >= 0 and nx <= resolution and nz >= 0 and nz <= resolution:
						var nidx: int = nz * (resolution + 1) + nx
						soma += vertices_temp[nidx].y * 1.0
						peso_total += 1.0
				
				var altura_suavizada: float = soma / peso_total
				vertices[index].y = lerp(vertices_temp[index].y, altura_suavizada, intensidade_suavizacao)
		
		vertices_temp = vertices.duplicate()

func _aplicar_erosao_hidraulica(vertices: PackedVector3Array, resolution: int) -> void:
	# Simula erosão simplificada em vales
	for z in range(1, resolution):
		for x in range(1, resolution):
			var index: int = z * (resolution + 1) + x
			var altura_atual: float = vertices[index].y
			
			# Calcular média dos vizinhos mais baixos
			var altura_min_vizinho: float = altura_atual
			var count_baixos: int = 0
			
			for dz in range(-1, 2):
				for dx in range(-1, 2):
					if dx == 0 and dz == 0:
						continue
					
					var nx: int = x + dx
					var nz: int = z + dz
					
					if nx >= 0 and nx <= resolution and nz >= 0 and nz <= resolution:
						var nidx: int = nz * (resolution + 1) + nx
						if vertices[nidx].y < altura_atual:
							altura_min_vizinho = min(altura_min_vizinho, vertices[nidx].y)
							count_baixos += 1
			
			# Se há vizinhos mais baixos, simular acúmulo de sedimento
			if count_baixos > 0:
				var diferenca: float = altura_atual - altura_min_vizinho
				var erosao: float = diferenca * fator_erosao_vales * 0.1
				vertices[index].y -= erosao

func _aplicar_arredondamento_bordas(vertices: PackedVector3Array, resolution: int, chunk_pos: Vector2i) -> void:
	if not arredondar_bordas_mapa:
		return
	
	var mundo_x_min: float = chunk_pos.x * tamanho_chunk
	var mundo_z_min: float = chunk_pos.y * tamanho_chunk
	var step: float = tamanho_chunk / float(resolution)
	
	#var centro_mapa: Vector2 = Vector2(
		#tamanho_mapa.x * tamanho_chunk / 2.0,
		#tamanho_mapa.y * tamanho_chunk / 2.0
	#)
	
	var index: int = 0
	
	for z in range(resolution + 1):
		for x in range(resolution + 1):
			var mundo_x: float = mundo_x_min + x * step
			var mundo_z: float = mundo_z_min + z * step
			
			var dist_borda_x: float = min(
				abs(mundo_x - 0),
				abs(mundo_x - (tamanho_mapa.x * tamanho_chunk))
			)
			var dist_borda_z: float = min(
				abs(mundo_z - 0),
				abs(mundo_z - (tamanho_mapa.y * tamanho_chunk))
			)
			var dist_min_borda: float = min(dist_borda_x, dist_borda_z)
			
			var fator_arredondamento: float = 1.0
			if dist_min_borda < distancia_arredondamento:
				fator_arredondamento = smoothstep(0.0, 1.0, dist_min_borda / distancia_arredondamento)
			
			var altura_original: float = vertices[index].y
			var altura_arredondada: float = altura_original * pow(fator_arredondamento, intensidade_bordas * 2.0)
			
			# Transição suave para água
			if altura_arredondada < 1.0:
				altura_arredondada = altura_arredondada * 0.2
			
			vertices[index].y = altura_arredondada
			index += 1

func _aplicar_suavizacao_bordas_chunks(vertices: PackedVector3Array, resolution: int) -> void:
	if not suavizar_bordas_chunks:
		return
	
	var step: float = tamanho_chunk / float(resolution)
	var index: int = 0
	
	for z in range(resolution + 1):
		for x in range(resolution + 1):
			var dist_borda_x: float = min(x * step, tamanho_chunk - x * step)
			var dist_borda_z: float = min(z * step, tamanho_chunk - z * step)
			var dist_min: float = min(dist_borda_x, dist_borda_z)
			
			if dist_min < distancia_suavizacao_borda:
				var fator: float = smoothstep(0.0, 1.0, dist_min / distancia_suavizacao_borda)
				var altura_original: float = vertices[index].y
				vertices[index].y = lerp(altura_original * 0.7, altura_original, fator)
			
			index += 1

func _pre_processar_terreno() -> void:
	if not arredondar_bordas_mapa or tamanho_mapa == Vector2i.ZERO:
		return
	
	if console_debug:
		print(\"[TerrainGen] Pré-processando bordas do mapa...\")

# =============================================================================
# SISTEMA DE MATERIAIS DINÂMICOS
# =============================================================================

func _aplicar_material_chunk(chunk_data: ChunkData) -> void:
	if material_terreno and not usar_material_dinamico:
		chunk_data.mesh_instance.set_surface_override_material(0, material_terreno)
		return
	
	if not usar_material_dinamico:
		chunk_data.mesh_instance.set_surface_override_material(0, _criar_material_grama())
		return
	
	# Sistema de multi-material por altura e inclinação
	var mesh: ArrayMesh = chunk_data.mesh_instance.mesh
	if not mesh:
		return
	
	# Para múltiplos materiais, precisaríamos dividir o mesh em múltiplas superfícies
	# Por simplicidade, vamos usar um material blended ou escolher o dominante
	var material_dominante: Material = _determinar_material_dominante(chunk_data)
	chunk_data.mesh_instance.set_surface_override_material(0, material_dominante)

func _determinar_material_dominante(chunk_data: ChunkData) -> Material:
	# Calcula altura média do chunk para determinar material
	var mesh: ArrayMesh = chunk_data.mesh_instance.mesh
	if not mesh:
		return material_grama
	
	var arrays: Array = mesh.surface_get_arrays(0)
	var vertices: PackedVector3Array = arrays[Mesh.ARRAY_VERTEX]
	
	var altura_media: float = 0.0
	for v in vertices:
		altura_media += v.y
	altura_media /= vertices.size()
	
	# Determinar material baseado na altura média
	if altura_media < altura_praia_max:
		return material_praia
	elif altura_media < altura_grama_max:
		return material_grama
	elif altura_media < altura_pedra_max:
		return material_pedra
	else:
		return material_neve

func _obter_cor_bioma_debug(altura: float) -> Color:
	if altura < altura_praia_max:
		return Color(0.85, 0.75, 0.55) # Areia
	elif altura < altura_grama_max:
		return Color(0.3, 0.6, 0.25) # Grama
	elif altura < altura_pedra_max:
		return Color(0.5, 0.5, 0.55) # Pedra
	else:
		return Color(0.95, 0.95, 1.0) # Neve

# =============================================================================
# CÁLCULO DE NORMAIS SUAVES
# =============================================================================

func _calcular_normais_suaves(vertices: PackedVector3Array, indices: PackedInt32Array) -> PackedVector3Array:
	var normals: PackedVector3Array = PackedVector3Array()
	normals.resize(vertices.size())
	normals.fill(Vector3.ZERO)
	
	# Acumular normais de todas as faces
	for i in range(0, indices.size(), 3):
		var i0: int = indices[i]
		var i1: int = indices[i + 1]
		var i2: int = indices[i + 2]
		
		var v0: Vector3 = vertices[i0]
		var v1: Vector3 = vertices[i1]
		var v2: Vector3 = vertices[i2]
		
		var edge1: Vector3 = v1 - v0
		var edge2: Vector3 = v2 - v0
		var normal: Vector3 = edge2.cross(edge1).normalized()
		
		# Peso por área do triângulo para normais mais precisas
		var area: float = edge1.cross(edge2).length() * 0.5
		
		normals[i0] += normal * area
		normals[i1] += normal * area
		normals[i2] += normal * area
	
	# Normalizar
	for i in range(normals.size()):
		if normals[i].length_squared() > 0.0001:
			normals[i] = normals[i].normalized()
		else:
			normals[i] = Vector3.UP
	
	return normals

func _atualizar_collision_shape(chunk_data: ChunkData, lod_level: int) -> void:
	if lod_level > 1 and otimizar_colisao_distante:
		chunk_data.collision_shape.disabled = true
		return
	
	chunk_data.collision_shape.disabled = false
	var mesh: ArrayMesh = chunk_data.mesh_instance.mesh
	if mesh:
		var shape: ConcavePolygonShape3D = mesh.create_trimesh_shape()
		if shape:
			chunk_data.collision_shape.shape = shape

# =============================================================================
# AUXILIARES
# =============================================================================

func _chunk_dentro_limites(chunk_pos: Vector2i) -> bool:
	if tamanho_mapa == Vector2i.ZERO:
		return true
	var half_size: Vector2i = tamanho_mapa / 2
	return abs(chunk_pos.x) <= half_size.x and abs(chunk_pos.y) <= half_size.y

func _limpar_cache_se_necessario() -> void:
	if mesh_cache.size() > max_cached_chunks:
		var keys: Array = mesh_cache.keys()
		var remover: int = keys.size() / 2
		for i in range(remover):
			mesh_cache.erase(keys[i])

func _limpar_altura_cache() -> void:
	var keys: Array = altura_cache.keys()
	var remover: int = keys.size() - 10000
	for i in range(remover):
		altura_cache.erase(keys[i])

func _debug_desenhar_bordas(chunk_data: ChunkData) -> void:
	for child in chunk_data.mesh_instance.get_children():
		if child.name == \"BorderDebug\":
			child.queue_free()
	
	var immediate: ImmediateMesh = ImmediateMesh.new()
	var mesh_inst: MeshInstance3D = MeshInstance3D.new()
	mesh_inst.name = \"BorderDebug\"
	mesh_inst.mesh = immediate
	chunk_data.mesh_instance.add_child(mesh_inst)
	
	var mat: StandardMaterial3D = StandardMaterial3D.new()
	mat.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	mat.albedo_color = Color.RED
	
	immediate.surface_begin(Mesh.PRIMITIVE_LINE_STRIP, mat)
	immediate.surface_add_vertex(Vector3(0, 0.2, 0))
	immediate.surface_add_vertex(Vector3(tamanho_chunk, 0.2, 0))
	immediate.surface_add_vertex(Vector3(tamanho_chunk, 0.2, tamanho_chunk))
	immediate.surface_add_vertex(Vector3(0, 0.2, tamanho_chunk))
	immediate.surface_add_vertex(Vector3(0, 0.2, 0))
	immediate.surface_end()

# =============================================================================
# LOOP DE ATUALIZAÇÃO
# =============================================================================

func _process(delta: float) -> void:
	if Engine.is_editor_hint():
		return
	
	timer += delta
	if timer < update_interval:
		return
	timer = 0.0
	
	if player_node and distancia_render > 0:
		_atualizar_chunks_ao_redor_player()
	
	if enable_lod:
		_atualizar_lod_chunks()
	
	if enable_frustum_culling and camera:
		_aplicar_frustum_culling()
	
	if limpar_chunks_distantes:
		_limpar_chunks_distantes()

func _atualizar_chunks_ao_redor_player() -> void:
	if not player_node:
		return
	
	var pos: Vector3 = player_node.global_position
	var chunk_player: Vector2i = Vector2i(
		int(floor(pos.x / tamanho_chunk)),
		int(floor(pos.z / tamanho_chunk))
	)
	
	var raio: int = int(distancia_render / tamanho_chunk) + 1
	var processados: int = 0
	
	for x in range(-raio, raio + 1):
		for z in range(-raio, raio + 1):
			if processados >= max_chunks_per_frame:
				return
			
			var chunk_pos: Vector2i = Vector2i(chunk_player.x + x, chunk_player.y + z)
			if _chunk_dentro_limites(chunk_pos) and not chunks_ativos.has(chunk_pos):
				var dist: float = Vector2(x, z).length() * tamanho_chunk
				if dist <= distancia_render:
					_criar_chunk(chunk_pos)
					processados += 1

func _atualizar_lod_chunks() -> void:
	if not player_node:
		return
	
	if debug_forcar_lod_unico:
		for chunk_pos in chunks_ativos.keys():
			var chunk_data: ChunkData = chunks_ativos[chunk_pos]
			if chunk_data.lod_atual != debug_lod_forcado:
				_gerar_mesh_chunk(chunk_data, debug_lod_forcado)
		return
	
	var pos: Vector3 = player_node.global_position
	
	for chunk_pos in chunks_ativos.keys():
		var chunk_data: ChunkData = chunks_ativos[chunk_pos]
		var dist: float = pos.distance_to(chunk_data.static_body.global_position)
		
		var novo_lod: int = 0
		for i in range(lod_distances.size()):
			if dist > lod_distances[i]:
				novo_lod = i + 1
		
		novo_lod = min(novo_lod, lod_resolutions.size() - 1)
		
		if novo_lod != chunk_data.lod_atual:
			_gerar_mesh_chunk(chunk_data, novo_lod)

func _aplicar_frustum_culling() -> void:
	if not camera:
		return
	
	var frustum: Array[Plane] = camera.get_frustum()
	
	for chunk_pos in chunks_ativos.keys():
		var chunk_data: ChunkData = chunks_ativos[chunk_pos]
		var aabb: AABB = chunk_data.mesh_instance.get_aabb()
		aabb.position += chunk_data.static_body.global_position
		
		var visivel: bool = true
		for plane in frustum:
			if plane.is_point_over(aabb.get_center()) and plane.distance_to(aabb.get_center()) > aabb.size.length():
				visivel = false
				break
		
		chunk_data.mesh_instance.visible = visivel

func _limpar_chunks_distantes() -> void:
	if not player_node or distancia_liberacao <= 0:
		return
	
	var pos: Vector3 = player_node.global_position
	var para_remover: Array[Vector2i] = []
	
	for chunk_pos in chunks_ativos.keys():
		var chunk_data: ChunkData = chunks_ativos[chunk_pos]
		var dist: float = pos.distance_to(chunk_data.static_body.global_position)
		
		if dist > distancia_liberacao:
			para_remover.append(chunk_pos)
	
	for chunk_pos in para_remover:
		_remover_chunk(chunk_pos)

func _remover_chunk(chunk_pos: Vector2i) -> void:
	if not chunks_ativos.has(chunk_pos):
		return
	
	var chunk_data: ChunkData = chunks_ativos[chunk_pos]
	chunks_ativos.erase(chunk_pos)
	
	if enable_chunk_pooling and chunk_pool.size() < max_cached_chunks:
		chunk_data.mesh_instance.visible = false
		chunk_pool.append(chunk_data)
	else:
		chunk_data.static_body.queue_free()

# =============================================================================
# FUNÇÕES PÚBLICAS
# =============================================================================

func regenerar_terreno(nova_seed: int = 0) -> void:
	if console_debug:
		print(\"[TerrainGen] Regenerando terreno...\")
	
	for chunk_pos in chunks_ativos.keys():
		var chunk_data: ChunkData = chunks_ativos[chunk_pos]
		chunk_data.static_body.queue_free()
	
	chunks_ativos.clear()
	chunk_pool.clear()
	mesh_cache.clear()
	altura_cache.clear()
	
	if nova_seed != 0:
		seed_geracao = nova_seed
	
	_inicializar_seed()
	_configurar_noise_multicamadas()
	_configurar_etapas_relevo()
	_gerar_chunks_iniciais()

func obter_altura_em_posicao(world_pos: Vector3) -> float:
	return _obter_altura_avancada(world_pos.x, world_pos.z)

func limpar_tudo() -> void:
	for chunk_pos in chunks_ativos.keys():
		var chunk_data: ChunkData = chunks_ativos[chunk_pos]
		chunk_data.static_body.queue_free()
	
	chunks_ativos.clear()
	chunk_pool.clear()
	mesh_cache.clear()
	altura_cache.clear()

func preencher_etapas(dados_etapas: Array) -> void:
	etapas_relevo.clear()
	
	for dado in dados_etapas:
		if typeof(dado) != TYPE_DICTIONARY:
			continue
		
		var etapa = EtapaRelevo.new()
		etapa.nome = dado.get(\"nome\", \"Etapa\")
		etapa.tipo_relevo = dado.get(\"tipo_relevo\", \"Rolling Hills\")
		etapa.percentual_distancia = float(dado.get(\"percentual_distancia\", 0))
		etapa.cor_visual = dado.get(\"cor_visual\", Color.WHITE)
		
		etapas_relevo.append(etapa)
	
	_configurar_etapas_relevo()

func alterar_parametros_noise(
	base_freq: float = -1.0,
	base_amp: float = -1.0,
	detail_freq: float = -1.0,
	detail_amp: float = -1.0,
	mountain_threshold: float = -1.0
) -> void:
	if base_freq > 0:
		frequencia_base = base_freq
	if base_amp > 0:
		amplitude_base = base_amp
	if detail_freq > 0:
		frequencia_detalhes = detail_freq
	if detail_amp > 0:
		amplitude_detalhes = detail_amp
	if mountain_threshold >= 0:
		threshold_montanhas = mountain_threshold
	
	_configurar_noise_multicamadas()
	regenerar_terreno(seed_geracao)

func obter_estatisticas() -> Dictionary:
	return {
		\"chunks_ativos\": chunks_ativos.size(),
		\"chunks_em_pool\": chunk_pool.size(),
		\"meshes_em_cache\": mesh_cache.size(),
		\"alturas_em_cache\": altura_cache.size(),
		\"seed_atual\": seed_geracao
	}
"

[node name="WorldGenerator" type="Node3D"]
script = SubResource("GDScript_om72s")
distancia_render = 0.0
altura_praia_max = 0.0
altura_grama_max = 3.0
altura_pedra_max = 25.0
angulo_pedra_min = 25.0
intensidade_suavizacao = 0.55
iteracoes_suavizacao = 3
simular_erosao_hidraulica = true

[node name="Sky3D" parent="." instance=ExtResource("1_mvrc1")]
current_time = 9.54661333304706
minutes_per_day = 10.0
